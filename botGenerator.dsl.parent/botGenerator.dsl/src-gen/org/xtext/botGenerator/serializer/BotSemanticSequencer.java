/*
 * generated by Xtext 2.23.0
 */
package org.xtext.botGenerator.serializer;

import com.google.inject.Inject;
import generator.BackToBot;
import generator.Bot;
import generator.BotInteraction;
import generator.Button;
import generator.ButtonAction;
import generator.CompositeInput;
import generator.Empty;
import generator.Entity;
import generator.EntityToken;
import generator.GeneratorPackage;
import generator.HTTPRequest;
import generator.HTTPRequestToke;
import generator.HTTPResponse;
import generator.Image;
import generator.Intent;
import generator.KeyValue;
import generator.LanguageButton;
import generator.LanguageEntity;
import generator.LanguageIntent;
import generator.LanguagePrompt;
import generator.LanguageText;
import generator.Literal;
import generator.ParameterReferenceToken;
import generator.ParameterToken;
import generator.RegexInput;
import generator.SimpleInput;
import generator.Text;
import generator.TextInput;
import generator.TrainingPhrase;
import generator.UserInteraction;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.botGenerator.services.BotGrammarAccess;

@SuppressWarnings("all")
public class BotSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BotGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GeneratorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GeneratorPackage.BACK_TO_BOT:
				sequence_BackToBot(context, (BackToBot) semanticObject); 
				return; 
			case GeneratorPackage.BOT:
				sequence_Bot(context, (Bot) semanticObject); 
				return; 
			case GeneratorPackage.BOT_INTERACTION:
				if (rule == grammarAccess.getState2Rule()) {
					sequence_State2(context, (BotInteraction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStateRule()) {
					sequence_State(context, (BotInteraction) semanticObject); 
					return; 
				}
				else break;
			case GeneratorPackage.BUTTON:
				sequence_Button(context, (Button) semanticObject); 
				return; 
			case GeneratorPackage.BUTTON_ACTION:
				sequence_ButtonAction(context, (ButtonAction) semanticObject); 
				return; 
			case GeneratorPackage.COMPOSITE_INPUT:
				sequence_CompositeInput(context, (CompositeInput) semanticObject); 
				return; 
			case GeneratorPackage.EMPTY:
				sequence_Empty(context, (Empty) semanticObject); 
				return; 
			case GeneratorPackage.ENTITY:
				if (rule == grammarAccess.getComplexEntityRule()) {
					sequence_ComplexEntity(context, (Entity) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityRule()) {
					sequence_ComplexEntity_RegexEntity_SimpleEntity(context, (Entity) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRegexEntityRule()) {
					sequence_RegexEntity(context, (Entity) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleEntityRule()) {
					sequence_SimpleEntity(context, (Entity) semanticObject); 
					return; 
				}
				else break;
			case GeneratorPackage.ENTITY_TOKEN:
				sequence_EntityToken(context, (EntityToken) semanticObject); 
				return; 
			case GeneratorPackage.HTTP_REQUEST:
				sequence_HTTPRequest(context, (HTTPRequest) semanticObject); 
				return; 
			case GeneratorPackage.HTTP_REQUEST_TOKE:
				sequence_HTTPRequestToken(context, (HTTPRequestToke) semanticObject); 
				return; 
			case GeneratorPackage.HTTP_RESPONSE:
				sequence_HTTPResponse(context, (HTTPResponse) semanticObject); 
				return; 
			case GeneratorPackage.IMAGE:
				sequence_Image(context, (Image) semanticObject); 
				return; 
			case GeneratorPackage.INTENT:
				if (rule == grammarAccess.getIntent1Rule()) {
					sequence_Intent1(context, (Intent) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIntentRule()) {
					sequence_Intent1_Intent2(context, (Intent) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIntent2Rule()) {
					sequence_Intent2(context, (Intent) semanticObject); 
					return; 
				}
				else break;
			case GeneratorPackage.KEY_VALUE:
				if (rule == grammarAccess.getDataRule()) {
					sequence_Data(context, (KeyValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyValueRule()) {
					sequence_KeyValue(context, (KeyValue) semanticObject); 
					return; 
				}
				else break;
			case GeneratorPackage.LANGUAGE_BUTTON:
				sequence_LanguageButton(context, (LanguageButton) semanticObject); 
				return; 
			case GeneratorPackage.LANGUAGE_ENTITY:
				if (rule == grammarAccess.getCLanguageEntityRule()) {
					sequence_CLanguageEntity(context, (LanguageEntity) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRLanguageEntityRule()) {
					sequence_RLanguageEntity(context, (LanguageEntity) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSLanguageEntityRule()) {
					sequence_SLanguageEntity(context, (LanguageEntity) semanticObject); 
					return; 
				}
				else break;
			case GeneratorPackage.LANGUAGE_INTENT:
				sequence_LanguageIntent(context, (LanguageIntent) semanticObject); 
				return; 
			case GeneratorPackage.LANGUAGE_PROMPT:
				sequence_LanguagePrompt(context, (LanguagePrompt) semanticObject); 
				return; 
			case GeneratorPackage.LANGUAGE_TEXT:
				if (rule == grammarAccess.getLanguageTextHttpResponseRule()) {
					sequence_LanguageTextHttpResponse(context, (LanguageText) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLanguageTextRule()) {
					sequence_LanguageText(context, (LanguageText) semanticObject); 
					return; 
				}
				else break;
			case GeneratorPackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case GeneratorPackage.PARAMETER:
				if (rule == grammarAccess.getParameter2Rule()) {
					sequence_Parameter2(context, (generator.Parameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterRule()) {
					sequence_Parameter(context, (generator.Parameter) semanticObject); 
					return; 
				}
				else break;
			case GeneratorPackage.PARAMETER_REFERENCE_TOKEN:
				sequence_ParameterRefenceToken(context, (ParameterReferenceToken) semanticObject); 
				return; 
			case GeneratorPackage.PARAMETER_TOKEN:
				sequence_ParameterToken(context, (ParameterToken) semanticObject); 
				return; 
			case GeneratorPackage.REGEX_INPUT:
				sequence_RegexInput(context, (RegexInput) semanticObject); 
				return; 
			case GeneratorPackage.SIMPLE_INPUT:
				sequence_SimpleInput(context, (SimpleInput) semanticObject); 
				return; 
			case GeneratorPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case GeneratorPackage.TEXT_INPUT:
				if (rule == grammarAccess.getTextInputHttpResponseRule()) {
					sequence_TextInputHttpResponse(context, (TextInput) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTextInputTextRule()) {
					sequence_TextInputText(context, (TextInput) semanticObject); 
					return; 
				}
				else break;
			case GeneratorPackage.TRAINING_PHRASE:
				sequence_TrainingPhrase(context, (TrainingPhrase) semanticObject); 
				return; 
			case GeneratorPackage.USER_INTERACTION:
				sequence_Transition(context, (UserInteraction) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BackToBot returns BackToBot
	 *
	 * Constraint:
	 *     (previous+=[Action|EString]* backTo=[BotInteraction|EString])
	 */
	protected void sequence_BackToBot(ISerializationContext context, BackToBot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Bot returns Bot
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         languages+=Language 
	 *         languages+=Language* 
	 *         intents+=Intent 
	 *         intents+=Intent* 
	 *         (entities+=Entity entities+=Entity*)? 
	 *         (actions+=Action actions+=Action*)? 
	 *         flows+=Transition+
	 *     )
	 */
	protected void sequence_Bot(ISerializationContext context, Bot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ButtonAction
	 *     ButtonAction returns ButtonAction
	 *
	 * Constraint:
	 *     (name=EString inputs+=LanguageButton)
	 */
	protected void sequence_ButtonAction(ISerializationContext context, ButtonAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Button returns Button
	 *
	 * Constraint:
	 *     (value=EString action=EString?)
	 */
	protected void sequence_Button(ISerializationContext context, Button semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CLanguageEntity returns LanguageEntity
	 *
	 * Constraint:
	 *     (language=Language? inputs+=CompositeInput inputs+=CompositeInput*)
	 */
	protected void sequence_CLanguageEntity(ISerializationContext context, LanguageEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexEntity returns Entity
	 *
	 * Constraint:
	 *     (name=EString inputs+=CLanguageEntity+)
	 */
	protected void sequence_ComplexEntity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     ((name=EString inputs+=SLanguageEntity+) | (name=EString inputs+=CLanguageEntity+) | (name=EString inputs+=RLanguageEntity+))
	 */
	protected void sequence_ComplexEntity_RegexEntity_SimpleEntity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositeInput returns CompositeInput
	 *
	 * Constraint:
	 *     (expresion+=Literal | expresion+=EntityToken)+
	 */
	protected void sequence_CompositeInput(ISerializationContext context, CompositeInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Data returns KeyValue
	 *
	 * Constraint:
	 *     (key=EString (value=Literal | value=ParameterToken))
	 */
	protected void sequence_Data(ISerializationContext context, KeyValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Empty
	 *     Empty returns Empty
	 *
	 * Constraint:
	 *     (name=EString description=EString?)
	 */
	protected void sequence_Empty(ISerializationContext context, Empty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Token returns EntityToken
	 *     EntityToken returns EntityToken
	 *
	 * Constraint:
	 *     entity=[Entity|EString]
	 */
	protected void sequence_EntityToken(ISerializationContext context, EntityToken semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.ENTITY_TOKEN__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.ENTITY_TOKEN__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityTokenAccess().getEntityEntityEStringParserRuleCall_1_0_1(), semanticObject.eGet(GeneratorPackage.Literals.ENTITY_TOKEN__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HTTPRequestToken returns HTTPRequestToke
	 *
	 * Constraint:
	 *     (type=HTTPReturnType dataKey=EString?)
	 */
	protected void sequence_HTTPRequestToken(ISerializationContext context, HTTPRequestToke semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns HTTPRequest
	 *     HTTPRequest returns HTTPRequest
	 *
	 * Constraint:
	 *     (
	 *         method=Method 
	 *         name=EString 
	 *         URL=EString 
	 *         basicAuth=KeyValue? 
	 *         (headers+=KeyValue headers+=KeyValue*)? 
	 *         (data+=Data data+=Data* dataType=DataType)?
	 *     )
	 */
	protected void sequence_HTTPRequest(ISerializationContext context, HTTPRequest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns HTTPResponse
	 *     HTTPResponse returns HTTPResponse
	 *
	 * Constraint:
	 *     (name=EString HTTPRequest=[HTTPRequest|EString] inputs+=LanguageTextHttpResponse+)
	 */
	protected void sequence_HTTPResponse(ISerializationContext context, HTTPResponse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Image
	 *     Image returns Image
	 *
	 * Constraint:
	 *     (name=EString URL=EString caption=EString?)
	 */
	protected void sequence_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Intent1 returns Intent
	 *
	 * Constraint:
	 *     (name=EString fallbackIntent?='Fallback'?)
	 */
	protected void sequence_Intent1(ISerializationContext context, Intent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Intent returns Intent
	 *
	 * Constraint:
	 *     (
	 *         (name=EString fallbackIntent?='Fallback'? inputs+=LanguageIntent* (parameters+=Parameter2* parameters+=Parameter)*) | 
	 *         (name=EString fallbackIntent?='Fallback'?)
	 *     )
	 */
	protected void sequence_Intent1_Intent2(ISerializationContext context, Intent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Intent2 returns Intent
	 *
	 * Constraint:
	 *     (name=EString fallbackIntent?='Fallback'? inputs+=LanguageIntent* (parameters+=Parameter2* parameters+=Parameter)*)
	 */
	protected void sequence_Intent2(ISerializationContext context, Intent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyValue returns KeyValue
	 *
	 * Constraint:
	 *     (key=EString value=Literal)
	 */
	protected void sequence_KeyValue(ISerializationContext context, KeyValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.KEY_VALUE__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.KEY_VALUE__KEY));
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.KEY_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.KEY_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyValueAccess().getKeyEStringParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getKeyValueAccess().getValueLiteralParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LanguageButton returns LanguageButton
	 *
	 * Constraint:
	 *     (language=Language? (inputs+=TextInputText inputs+=TextInputText*)? buttons+=Button+)
	 */
	protected void sequence_LanguageButton(ISerializationContext context, LanguageButton semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LanguageIntent returns LanguageIntent
	 *
	 * Constraint:
	 *     (language=Language? inputs+=TrainingPhrase inputs+=TrainingPhrase*)
	 */
	protected void sequence_LanguageIntent(ISerializationContext context, LanguageIntent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LanguagePrompt returns LanguagePrompt
	 *
	 * Constraint:
	 *     (language=Language? prompts+=EString prompts+=EString*)
	 */
	protected void sequence_LanguagePrompt(ISerializationContext context, LanguagePrompt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LanguageTextHttpResponse returns LanguageText
	 *
	 * Constraint:
	 *     (language=Language? inputs+=TextInputHttpResponse inputs+=TextInputHttpResponse*)
	 */
	protected void sequence_LanguageTextHttpResponse(ISerializationContext context, LanguageText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LanguageText returns LanguageText
	 *
	 * Constraint:
	 *     (language=Language? inputs+=TextInputText inputs+=TextInputText*)
	 */
	protected void sequence_LanguageText(ISerializationContext context, LanguageText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Token returns Literal
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     text=EString
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.LITERAL__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.LITERAL__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getTextEStringParserRuleCall_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter2 returns Parameter
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Parameter2(ISerializationContext context, generator.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameter2Access().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Token returns ParameterReferenceToken
	 *     ParameterRefenceToken returns ParameterReferenceToken
	 *
	 * Constraint:
	 *     (textReference=EString parameter=[Parameter|EString])
	 */
	protected void sequence_ParameterRefenceToken(ISerializationContext context, ParameterReferenceToken semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.PARAMETER_REFERENCE_TOKEN__TEXT_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.PARAMETER_REFERENCE_TOKEN__TEXT_REFERENCE));
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.PARAMETER_REFERENCE_TOKEN__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.PARAMETER_REFERENCE_TOKEN__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterRefenceTokenAccess().getTextReferenceEStringParserRuleCall_1_0(), semanticObject.getTextReference());
		feeder.accept(grammarAccess.getParameterRefenceTokenAccess().getParameterParameterEStringParserRuleCall_4_0_1(), semanticObject.eGet(GeneratorPackage.Literals.PARAMETER_REFERENCE_TOKEN__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Token returns ParameterToken
	 *     ParameterToken returns ParameterToken
	 *
	 * Constraint:
	 *     (parameter=[Parameter|EString] info=EString?)
	 */
	protected void sequence_ParameterToken(ISerializationContext context, ParameterToken semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=EString (entity=[Entity|EString] | defaultEntity=DefaultEntity) isList?='isList'? required?='required'? prompts+=LanguagePrompt*)
	 */
	protected void sequence_Parameter(ISerializationContext context, generator.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RLanguageEntity returns LanguageEntity
	 *
	 * Constraint:
	 *     (language=Language? inputs+=RegexInput inputs+=RegexInput*)
	 */
	protected void sequence_RLanguageEntity(ISerializationContext context, LanguageEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegexEntity returns Entity
	 *
	 * Constraint:
	 *     (name=EString inputs+=RLanguageEntity+)
	 */
	protected void sequence_RegexEntity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegexInput returns RegexInput
	 *
	 * Constraint:
	 *     expresion=EString
	 */
	protected void sequence_RegexInput(ISerializationContext context, RegexInput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.REGEX_INPUT__EXPRESION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.REGEX_INPUT__EXPRESION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegexInputAccess().getExpresionEStringParserRuleCall_3_0(), semanticObject.getExpresion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SLanguageEntity returns LanguageEntity
	 *
	 * Constraint:
	 *     (language=Language? inputs+=SimpleInput inputs+=SimpleInput*)
	 */
	protected void sequence_SLanguageEntity(ISerializationContext context, LanguageEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleEntity returns Entity
	 *
	 * Constraint:
	 *     (name=EString inputs+=SLanguageEntity+)
	 */
	protected void sequence_SimpleEntity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleInput returns SimpleInput
	 *
	 * Constraint:
	 *     (name=EString (values+=EString values+=EString*)?)
	 */
	protected void sequence_SimpleInput(ISerializationContext context, SimpleInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State2 returns BotInteraction
	 *
	 * Constraint:
	 *     (name=EString? actions+=[Action|EString] actions+=[Action|EString]* (outcoming+=Transition | backTo+=[UserInteraction|EString])*)
	 */
	protected void sequence_State2(ISerializationContext context, BotInteraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns BotInteraction
	 *
	 * Constraint:
	 *     (name=EString? actions+=[Action|EString] actions+=[Action|EString]* (outcoming+=Transition | backTo+=[UserInteraction|EString]))
	 */
	protected void sequence_State(ISerializationContext context, BotInteraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextInputHttpResponse returns TextInput
	 *
	 * Constraint:
	 *     (tokens+=Literal | tokens+=ParameterToken | tokens+=HTTPRequestToken)+
	 */
	protected void sequence_TextInputHttpResponse(ISerializationContext context, TextInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextInputText returns TextInput
	 *
	 * Constraint:
	 *     (tokens+=Literal | tokens+=ParameterToken)+
	 */
	protected void sequence_TextInputText(ISerializationContext context, TextInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Text
	 *     Text returns Text
	 *
	 * Constraint:
	 *     (name=EString inputs+=LanguageText+)
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TrainingPhrase returns TrainingPhrase
	 *
	 * Constraint:
	 *     (tokens+=Literal | tokens+=ParameterRefenceToken)+
	 */
	protected void sequence_TrainingPhrase(ISerializationContext context, TrainingPhrase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transition returns UserInteraction
	 *
	 * Constraint:
	 *     (name=EString? intent=[Intent|EString] (target=State2 | target=State | backTo=BackToBot)?)
	 */
	protected void sequence_Transition(ISerializationContext context, UserInteraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
